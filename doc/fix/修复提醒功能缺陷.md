提醒功能漏洞修复

1. ReminderDelayQueueWorker.java:116 - 异步删除导致的重复发送风险
   future.thenAccept(result -> {
   redisUtil.removeFromZSet(CORE_REMINDER_SEND_QUEUE_KEY, key);
   })
   问题：Kafka发送成功但应用突然崩溃 → ZSet未删除 → 下次扫描重复发送。 建议：先删除ZSet，再发送Kafka；或使用事务消息。
2. ReminderScanScheduler.java:71-83 - Kafka与DB更新顺序问题
   for (Reminder reminder : toTriggerReminderList) {
   forwardToPendingQueue(reminder);  // 先发Kafka
   // ...再更新数据库
   reminderService.updateNextTriggerTimeById(...);
   }
   问题：Kafka发送成功但DB更新失败 → 下次扫描重复触发。
3. ReminderPendingConsumer.java:59-62 - 异常吞没导致消息丢失
   catch (Exception e) {
   log.error("消费消息失败，key: {}", key, e);
   // Kafka 会自动重试，或手动处理
   }
   实际未抛出异常，Kafka不会重试，消息直接丢失。
4. 提前量设置边缘情况 - 可能存入Redis后又立即被扫描

场景：remindBeforeMinutes = 1，定时任务每1分钟执行：
- 14:00 Scanner 扫到14:01到期的提醒 → 发pending
- Pending消费 → 计算延迟 ~0ms → 判断已到期，直接发SEND
- 正确，不会存Redis

场景：remindBeforeMinutes = 30：
- 14:00 Scanner 扫到14:30到期的提醒 → 发pending
- Pending消费 → notificationTime = 14:00 → 延迟 ~0ms → 直接发SEND
- 问题：remindBeforeMinutes是提前量，notificationTime应该 = scheduleTime - remindBeforeMinutes

代码中 ReminderPendingConsumer:122 行：
LocalDateTime notificationTime = (remindMinutes != null && remindMinutes > 0) ?
messageDto.getNextTriggerTime().minusMinutes(remindMinutes) :
messageDto.getNextTriggerTime();
如果 nextTriggerTime = 14:30, remindBeforeMinutes = 30，则 notificationTime = 14:00，消费时已经到期，不会存Redis。
这个逻辑是合理的。

  ---
优先级建议

| 优先级 | 问题            | 修复                              |
|--------|---------------|-----------------------------------|
| 高     | #1 异步删除风险     | 先删ZSet再发Kafka，或加唯一键去重 |
| 中     | #2 Kafka与DB顺序 | DB更新成功后再发Kafka，或使用事务 |
| 高     | #3 消息丢失风险     | 异常需抛出或记录到死信队列        |


 ---
修复结果

| 优先级 | 问题                             | 状态      |
|--------|--------------------------------|-----------|
| 高     | #1 异步删除风险 - 先删ZSet再发Kafka      | ✅ 已修复 |
| 中     | #2 Kafka与DB顺序 - DB更新成功后再发Kafka | ✅ 已修复 |
| 高     | #3 消息丢失风险 - 异常需抛出              | ✅ 已修复 |


