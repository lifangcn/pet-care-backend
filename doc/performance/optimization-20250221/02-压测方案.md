# 积分系统压测方案

创建时间: 2025-02-21
作者: Michael Li

---

## 一、压测目标

### 1.1 验证性能瓶颈
- Kafka 同步发送影响
- 分布式锁串行化影响
- Redis 访问性能
- 数据库查询性能

### 1.2 优化前后对比
- 响应时间对比
- QPS 对比
- 错误率对比
- 资源使用对比

---

## 二、压测工具选择

### 2.1 工具对比

| 工具 | 优势 | 劣势 | 适用场景 |
|------|------|------|----------|
| **wrk2** | 极高性能，固定 QPS | Lua 脚本复杂 | 单接口压测 |
| **k6** | JS 脚本，现代易用 | 单机性能弱于 wrk | 复杂场景 |
| **JMeter** | 功能完整，GUI | 资源占用高 | 详细报告 |

### 2.2 本次选择

**主要工具**: wrk2（快速验证）
**辅助工具**: k6（复杂场景）

---

## 三、压测场景设计

### 3.1 基准场景 - 消耗积分
> 添加 JVM参数： -Djwt.test.mode=true
#### 场景 A: 单用户高并发（验证锁串行化）

```bash
# wrk2 命令
wrk -t4 -c100 -d60s -R1000 \
  -s consume_single.lua \
  http://localhost:8080/api/points/consume
```

**参数说明**:
| 参数 | 值 | 说明 |
|------|-----|------|
| 线程数 | 4 | CPU 核心数相关 |
| 连接数 | 100 | 并发连接 |
| 时长 | 60s | 足够样本量 |
| 请求速率 | 1000 | 固定 QPS |

**预期结果**:
- 响应时间 > 1000ms（锁排队）
- QPS < 100（锁持有时间限制）

---

#### 场景 B: 多用户并发（验证系统吞吐）

```bash
wrk -t4 -c500 -d60s -R5000 \
  -s consume_multi.lua \
  http://localhost:8080/api/points/consume
```

**参数说明**:
| 参数 | 值 | 说明 |
|------|-----|------|
| 连接数 | 500 | 模拟高并发 |
| 用户数 | 1000 | Lua 脚本随机 |
| 请求速率 | 5000 | 固定 QPS |

**预期结果**:
- QPS > 300
- 响应时间 < 500ms

---

### 3.2 辅助场景

#### 场景 C: 签到获取积分

```bash
wrk -t4 -c100 -d60s -R1000 \
  -s checkin.lua \
  http://localhost:8080/api/points/checkin
```

#### 场景 D: 点赞质量积分

```bash
wrk -t4 -c200 -d60s -R2000 \
  -s like.lua \
  http://localhost:8080/api/points/like
```

---

## 四、Lua 脚本示例

### 4.1 消耗积分（单用户）

```lua
-- consume_single.lua
wrk.method = "POST"
wrk.body   = '{"userId": 1001, "points": -10, "actionType": "CONSUME"}'
wrk.headers["Content-Type"] = "application/json"
wrk.headers["X-Test-User-Id"] = "1001"
```

### 4.2 消耗积分（多用户）

```lua
-- consume_multi.lua
wrk.method = "POST"

-- 1000 个测试用户
local user_ids = {}
for i = 1, 1000 do
  table.insert(user_ids, i)
end

local index = 0
request = function()
  index = index % 1000 + 1
  local user_id = user_ids[index]

  local body = string.format(
    '{"userId": %d, "points": -10, "actionType": "CONSUME"}',
    user_id
  )

  return wrk.format(nil, nil, nil, body)
end

-- 设置请求头
wrk.headers["Content-Type"] = "application/json"
```

### 4.3 点赞

```lua
-- like.lua
wrk.method = "POST"

local content_id = 0
request = function()
  content_id = content_id % 1000 + 1

  local body = string.format(
    '{"authorId": %d, "contentId": %d, "interactUserId": 1}',
    content_id % 100 + 1,  -- 作者 ID
    content_id,             -- 内容 ID
    1                       -- 互动用户
  )

  return wrk.format(nil, nil, nil, body)
end

wrk.headers["Content-Type"] = "application/json"
```

---

## 五、监控指标

### 5.1 应用指标

```bash
# 使用 curl 监控
watch -n 1 'curl -s http://localhost:8080/actuator/metrics/jvm.memory.used'
```

### 5.2 数据库指标

```sql
-- MySQL 慢查询
SHOW VARIABLES LIKE 'slow_query_log';
SHOW VARIABLES LIKE 'long_query_time';

-- 查看当前连接
SHOW PROCESSLIST;
```

### 5.3 Redis 指标

```bash
# Redis 监控
redis-cli info stats
redis-cli --stat
```

---

## 六、压测流程

### 6.1 准备阶段

```bash
# 1. 启用测试模式
export JWT_TEST_MODE=true

# 2. 初始化测试数据
mysql -u root -p petcare < doc/performance/init_test_data.sql

# 3. 启动应用
java -jar pet-care-core.jar

# 4. 验证接口可用
curl -X POST http://localhost:8080/api/points/consume \
  -H "Content-Type: application/json" \
  -H "X-Test-User-Id: 1" \
  -d '{"userId": 1, "points": -10, "actionType": "CONSUME"}'
```

### 6.2 执行阶段

```bash
# 基准测试（优化前）
cd doc/performance/optimization-20250221

# 单用户场景
wrk -t4 -c100 -d60s -R1000 -s consume_single.lua http://localhost:8080/api/points/consume > baseline_single.log

# 多用户场景
wrk -t4 -c500 -d60s -R5000 -s consume_multi.lua http://localhost:8080/api/points/consume > baseline_multi.log
```

### 6.3 优化后测试

```bash
# 代码优化后，重复执行
wrk -t4 -c100 -d60s -R1000 -s consume_single.lua \
  http://localhost:8080/api/points/consume \
  > optimized_single.log

wrk -t4 -c500 -d60s -R5000 -s consume_multi.lua \
  http://localhost:8080/api/points/consume \
  > optimized_multi.log
```

---

## 七、结果分析

### 7.1 wrk2 输出解读

```
Running 60s test @ http://localhost:8080/api/points/consume
  4 threads and 100 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   234.56ms  123.45ms   1.50s    76.78%
    Req/Sec    56.78     12.34    80.00     68.90%
  60000 requests in 60.00s, 12.34MB read
  Non-2xx responses: 123

Requests/sec:    1000.00
Transfer/sec:    205.67KB
```

**关键指标**:
| 指标 | 说明 |
|------|------|
| Latency Avg | 平均响应时间 |
| Latency Max | 最大响应时间 |
| Req/Sec | 每秒请求数 |
| Non-2xx | 错误请求数 |

### 7.2 对比模板

```markdown
| 场景 | 指标 | 优化前 | 优化后 | 提升 |
|------|------|--------|--------|------|
| 单用户 | 平均响应 |  |  |  |
| 单用户 | QPS |  |  |  |
| 多用户 | 平均响应 |  |  |  |
| 多用户 | QPS |  |  |  |
```

---

## 八、注意事项

### 8.1 测试环境

- 独立测试环境，避免影响生产
- 数据配置与生产一致
- 网络隔离，减少外部干扰

### 8.2 数据清理

```sql
-- 压测后清理流水
DELETE FROM tb_points_record
WHERE created_at >= '2025-02-21 00:00:00';

-- 重置积分账户
UPDATE tb_points_account
SET available_points = 10000
WHERE user_id <= 1000;
```

### 8.3 安全检查

```bash
# 确认是测试环境
curl http://localhost:8080/actuator/env | grep test

# 确认数据库连接
echo "SELECT DATABASE();" | mysql -u root -p petcare
```
