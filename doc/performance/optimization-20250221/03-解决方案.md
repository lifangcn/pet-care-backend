# 积分系统性能优化方案

创建时间: 2025-02-21
作者: Michael Li

---

## 一、优化清单

| ID | 优化项 | 优先级 | 预计收益 | 实现难度 |
|----|--------|--------|----------|----------|
| P1 | Kafka 异步发送 | P0 | 响应 -20ms | 低 |
| P2 | 锁内查询外置 | P0 | 锁时间 -40% | 低 |
| P3 | 消除冗余查询 | P1 | DB QPS -50% | 低 |
| P4 | 合并 Redis 检查 | P1 | Redis QPS -30% | 低 |
| P5 | Set 过期优化 | P2 | Redis QPS -10% | 低 |
| P6 | 账户缓存 | P2 | DB QPS -30% | 中 |

---

## 二、详细方案

### P1: Kafka 异步发送

**当前代码** (`PointsServiceImpl:268`):
```java
kafkaTemplate.send(CORE_POINTS_RECORD_SAVE_TOPIC, key, value).get();
```

**问题**: `.get()` 阻塞等待 Kafka 确认

**优化方案**:
```java
/**
 * {@code @description}: 发送积分记录流水处理队列（异步）
 * {@code @date}: 2025-02-21
 * {@code @author}: Michael Li
 */
private void sendMessageToPointsRecordSave(PointsRecord record) {
    String key = record.getBizId() != null ? record.getBizId().toString() : "0";
    String value = JSONUtil.toJsonStr(record);

    // 异步发送，不阻塞主流程
    kafkaTemplate.send(CORE_POINTS_RECORD_SAVE_TOPIC, key, value)
        .addCallback(
            success -> log.debug("积分流水发送成功: {}", record.getId()),
            failure -> log.error("积分流水发送失败: {}", record.getId(), failure)
        );
}
```

**权衡**:
- 优势: 响应时间减少 20ms+
- 劣势: Kafka 不可用时无感知
- 补偿: Kafka 消费者需处理幂等

---

### P2: 锁内查询外置

**当前代码** (`PointsServiceImpl:139-165`):
```java
PointsRecord pointsRecord = transactionTemplate.execute(status ->
    redissonLockUtil.executeWithLock(CORE_POINTS_LOCK_KEY_PREFIX + userId, () -> {
        // 锁内查询券表
        PointsCoupon coupon = pointsCouponMapper.selectOneById(couponId);
        if (coupon == null) {
            throw new BusinessException(ErrorCode.PARAM_ERROR, "券不存在");
        }
        ...
    }, 1, 10));
```

**优化方案**:
```java
@Override
public Integer earnByCoupon(Long userId, Long couponId) {
    // 锁外查询券表
    PointsCoupon coupon = pointsCouponMapper.selectOneById(couponId);
    if (coupon == null) {
        throw new BusinessException(ErrorCode.PARAM_ERROR, "券不存在");
    }

    PointsRecord pointsRecord = transactionTemplate.execute(status ->
        redissonLockUtil.executeWithLock(CORE_POINTS_LOCK_KEY_PREFIX + userId, () -> {
            PointsAccount account = getOrCreateAccount(userId);
            Integer points = coupon.getFaceValue();

            updateChain()
                .set(POINTS_ACCOUNT.AVAILABLE_POINTS, account.getAvailablePoints() + points)
                .set(POINTS_ACCOUNT.TOTAL_POINTS, account.getTotalPoints() + points)
                .where(POINTS_ACCOUNT.USER_ID.eq(userId))
                .update();

            PointsRecord record = new PointsRecord();
            record.setUserId(account.getUserId());
            record.setPoints(points);
            record.setPointsBefore(account.getAvailablePoints());
            record.setPointsAfter(account.getAvailablePoints() + points);
            record.setActionType(ActionTypeOfPointsRecord.COUPON_REDEEM);
            record.setBizId(couponId);
            return record;
        }, 1, 10));

    if (pointsRecord != null) {
        sendMessageToPointsRecordSave(pointsRecord);
    }
    return pointsRecord != null ? pointsRecord.getPoints() : 0;
}
```

**权衡**:
- 优势: 锁持有时间减少 40%
- 劣势: 券可能在查询后、使用前被删除
- 风险: 低（券删除场景极少）

---

### P3: 消除冗余查询

**当前代码** (`PointsServiceImpl:236`):
```java
// 数据库原子更新
boolean updated = UpdateChain.of(PointsAccount.class)
    .set(POINTS_ACCOUNT.AVAILABLE_POINTS, ...)
    .where(...).update();

// 立即再查
PointsAccount accountAfter = getOne(QueryWrapper.create()
    .where(POINTS_ACCOUNT.USER_ID.eq(request.getUserId())));
```

**优化方案**:
```java
@Override
public boolean consume(PointsConsumeRequest request) {
    PointsRecord pointsRecord = transactionTemplate.execute(status -> {
        Integer pointsToConsume = Math.abs(request.getPoints());

        // 先查询当前余额（用于记录 pointsBefore）
        PointsAccount accountBefore = getOne(
            QueryWrapper.create().where(POINTS_ACCOUNT.USER_ID.eq(request.getUserId()))
        );

        // 数据库层面原子更新
        boolean updated = UpdateChain.of(PointsAccount.class)
            .set(POINTS_ACCOUNT.AVAILABLE_POINTS,
                POINTS_ACCOUNT.AVAILABLE_POINTS.subtract(pointsToConsume))
            .set(POINTS_ACCOUNT.TOTAL_POINTS,
                POINTS_ACCOUNT.TOTAL_POINTS.subtract(pointsToConsume))
            .where(POINTS_ACCOUNT.USER_ID.eq(request.getUserId()))
            .and(POINTS_ACCOUNT.AVAILABLE_POINTS.ge(pointsToConsume))
            .update();

        if (!updated) {
            throw new BusinessException(ErrorCode.POINTS_NOT_ENOUGH);
        }

        // 计算更新后的余额（无需再次查询）
        Integer pointsAfter = accountBefore.getAvailablePoints() - pointsToConsume;

        // 创建积分记录对象
        PointsRecord toSave = new PointsRecord();
        toSave.setUserId(request.getUserId());
        toSave.setPoints(request.getPoints());
        toSave.setPointsBefore(accountBefore.getAvailablePoints());
        toSave.setPointsAfter(pointsAfter);  // 使用计算值
        toSave.setActionType(ActionTypeOfPointsRecord.fromCode(request.getActionType()).get());
        toSave.setBizType(request.getBizType());
        toSave.setBizId(request.getBizId());
        toSave.setCouponId(request.getCouponId());
        return toSave;
    });

    if (pointsRecord != null) {
        sendMessageToPointsRecordSave(pointsRecord);
    }
    return true;
}
```

**权衡**:
- 优势: 减少一次数据库查询
- 注意: 需保证在事务内，数据一致性

---

### P4: 合并 Redis 检查

**当前代码** (`PointsServiceImpl:94-105`):
```java
// 第一次检查
int count = pointsCacheService.getActionCount(userId, action);
if (count >= limit) {
    return 0;
}

// 第二次检查
int currentCount = pointsCacheService.getActionCount(userId, action);
if (currentCount >= limit) {
    return 0;
}
```

**优化方案**:
```java
@Override
public Integer earnByAction(Long userId, ActionTypeOfPointsRecord action, Long bizId) {
    // 只检查一次
    int count = pointsCacheService.getActionCount(userId, action);
    int limit = getDailyLimit(action);
    if (count >= limit) {
        log.info("用户{}今日行为{}已达上限", userId, action);
        return 0;
    }

    PointsRecord pointsRecord = transactionTemplate.execute(status ->
        redissonLockUtil.executeWithLock(CORE_POINTS_LOCK_KEY_PREFIX + userId, () -> {
            // 锁内再次检查（防止并发超限）
            int lockCount = pointsCacheService.getActionCount(userId, action);
            if (lockCount >= limit) {
                return null;
            }

            PointsAccount account = getOrCreateAccount(userId);
            Integer points = action.getPoints();

            updateChain()
                .set(POINTS_ACCOUNT.AVAILABLE_POINTS, account.getAvailablePoints() + points)
                .set(POINTS_ACCOUNT.TOTAL_POINTS, account.getTotalPoints() + points)
                .where(POINTS_ACCOUNT.USER_ID.eq(userId))
                .update();

            PointsRecord record = new PointsRecord();
            record.setUserId(account.getUserId());
            record.setPoints(points);
            record.setPointsBefore(account.getAvailablePoints());
            record.setPointsAfter(account.getAvailablePoints() + points);
            record.setActionType(action);
            record.setBizId(bizId);

            // 锁内增加计数（保证原子性）
            pointsCacheService.incrementActionCount(userId, action);
            return record;
        }, 1, 10));

    if (pointsRecord != null) {
        sendMessageToPointsRecordSave(pointsRecord);
    }
    return pointsRecord != null ? action.getPoints() : 0;
}
```

**说明**: 将计数增加移到锁内，保证原子性，避免双重检查

---

### P5: Set 过期优化

**当前代码** (`PointsCacheServiceImpl:50-57`):
```java
public boolean checkAndAddInteraction(Long contentId, Long userId, ActionTypeOfPointsRecord action) {
    String key = buildInteractionKey(contentId, action);
    RSet<String> set = redissonClient.getSet(key);
    // 每次 add 都调用 expire
    set.expire(getEndOfToday());
    return set.add(userId.toString());
}
```

**优化方案**:
```java
@Override
public boolean checkAndAddInteraction(Long contentId, Long userId, ActionTypeOfPointsRecord action) {
    String key = buildInteractionKey(contentId, action);
    RSet<String> set = redissonClient.getSet(key);

    // 只有在首次创建时设置过期时间
    if (!set.isExists() || !set.expireTime().isPresent()) {
        set.expire(getEndOfToday());
    }

    return set.add(userId.toString());
}
```

**权衡**:
- 优势: 减少 Redis 命令
- 劣势: 增加 `isExists()` 检查
- 净收益: 高频场景下显著

---

### P6: 账户缓存

**新增缓存服务**:
```java
/**
 * {@code @description}: 积分账户缓存服务
 * {@code @date}: 2025-02-21
 * {@code @author}: Michael Li
 */
@Service
@RequiredArgsConstructor
public class PointsAccountCacheService {

    private final RedissonClient redissonClient;
    private final PointsAccountMapper pointsAccountMapper;

    private static final String CACHE_KEY_PREFIX = "core:points:account:";
    private static final Duration CACHE_TTL = Duration.ofHours(1);

    public PointsAccount getOrLoad(Long userId) {
        String key = CACHE_KEY_PREFIX + userId;
        RMap<String, Integer> cache = redissonClient.getMap(key);

        // 缓存存在
        if (cache.isExists()) {
            Integer available = cache.get("available");
            Integer total = cache.get("total");
            PointsAccount account = new PointsAccount();
            account.setUserId(userId);
            account.setAvailablePoints(available);
            account.setTotalPoints(total);
            return account;
        }

        // 缓存不存在，从数据库加载
        PointsAccount account = pointsAccountMapper.selectOneByUserId(userId);
        if (account == null) {
            account = new PointsAccount();
            account.setUserId(userId);
            account.setAvailablePoints(0);
            account.setTotalPoints(0);
        }

        // 写入缓存
        cache.put("available", account.getAvailablePoints());
        cache.put("total", account.getTotalPoints());
        cache.expire(CACHE_TTL);

        return account;
    }

    public void invalidate(Long userId) {
        String key = CACHE_KEY_PREFIX + userId;
        redissonClient.getBucket(key).delete();
    }
}
```

**使用方式**:
```java
// 在 PointsServiceImpl 中使用
private final PointsAccountCacheService accountCacheService;

private PointsAccount getOrCreateAccount(Long userId) {
    return accountCacheService.getOrLoad(userId);
}

// 积分变更后失效缓存
public boolean consume(PointsConsumeRequest request) {
    // ... 消费逻辑

    // 失效缓存
    accountCacheService.invalidate(request.getUserId());

    return true;
}
```

**权衡**:
- 优势: 大幅减少数据库查询
- 劣势: 增加缓存复杂度
- 注意: 需确保缓存一致性

---

## 三、实施顺序

### 第一阶段（低风险高收益）

```
P1: Kafka 异步发送
  └─ 风险: 低
  └─ 收益: 响应 -20ms
  └─ 测试: 单元测试 + 压测对比

P3: 消除冗余查询
  └─ 风险: 低
  └─ 收益: DB QPS -50%
  └─ 测试: 单元测试
```

### 第二阶段（中等风险）

```
P2: 锁内查询外置
  └─ 风险: 中
  └─ 收益: 锁时间 -40%
  └─ 测试: 并发测试 + 边界条件

P4: 合并 Redis 检查
  └─ 风险: 中
  └─ 收益: Redis QPS -30%
  └─ 测试: 并发测试
```

### 第三阶段（可选）

```
P5: Set 过期优化
P6: 账户缓存
```

---

## 四、验证方案

### 4.1 单元测试

```java
@SpringBootTest
class PointsServiceImplTest {

    @Test
    void testConsume_余额不足_抛出异常() {
        // 测试余额不足场景
    }

    @Test
    void testConsume_并发消费_数据一致() {
        // 并发测试，验证原子性
        int threads = 100;
        CountDownLatch latch = new CountDownLatch(threads);

        for (int i = 0; i < threads; i++) {
            new Thread(() -> {
                pointsService.consume(request);
                latch.countDown();
            }).start();
        }

        latch.await();
        // 验证余额正确
    }
}
```

### 4.2 压测对比

```bash
# 优化前
wrk -t4 -c500 -d60s -R5000 -s consume_multi.lua \
  http://localhost:8080/api/points/consume \
  > before.log

# 优化后
wrk -t4 -c500 -d60s -R5000 -s consume_multi.lua \
  http://localhost:8080/api/points/consume \
  > after.log

# 对比
diff before.log after.log
```

---

## 五、回滚方案

### 5.1 配置开关

```yaml
# application.yml
points:
  optimization:
    kafka-async: true   # Kafka 异步开关
    account-cache: false # 缓存开关
```

### 5.2 灰度发布

```java
@Value("${points.optimization.kafka-async:false}")
private boolean kafkaAsyncEnabled;

private void sendMessageToPointsRecordSave(PointsRecord record) {
    if (kafkaAsyncEnabled) {
        // 异步发送
        kafkaTemplate.send(...).addCallback(...);
    } else {
        // 同步发送
        kafkaTemplate.send(...).get();
    }
}
```

---

## 六、监控指标

### 优化后需关注

| 指标 | 优化前 | 目标 |
|------|--------|------|
| P50 响应时间 |  | ↓ 30% |
| P95 响应时间 |  | ↓ 40% |
| P99 响应时间 |  | ↓ 50% |
| QPS |  | ↑ 50% |
| DB QPS |  | ↓ 30% |
| 错误率 | 0% | ≤ 0.01% |
